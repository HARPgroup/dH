<?php


function dh_schema() {
   // 
   $schema['dh_feature_type'] = array (
    'description' => 'Base Feature class in dh (ArcHydro: Feature)',
    'fields' => array(
      'fid' => array(
        'description' => 'Primary key for Feature Types',
        'type' => 'serial',
        'unsigned' => TRUE,
        'not null' => TRUE,
      ),
      'name' => array(
        'description' => 'Feature Name (Watershed, Waterbody, Monitoring Point, etc)',
        'type' => 'varchar',
		    'length' => 64,
        'not null' => TRUE,
		    'default' => '',
      ),
      'bundle' => array(
        'description' => 'Feature Type / Bundle (watershed, waterbody, monitoringpoint, etc)',
        'type' => 'varchar',
		    'length' => 64,
        'not null' => TRUE,
		    'default' => '',
      ),
      'description' => array(
        'description' => 'Description of this Feature Class',
        'type' => 'varchar',
		    'length' => 255,
        'not null' => TRUE,
		    'default' => '',
      ),
   ) + entity_exportable_schema_fields(),
   'primary key' => array('fid'),
	'indexes' => array(
	   'dh_fet_fix'      => array('fid'),
	   'dh_fet_ftix'        => array('bundle')
	)
   );
  
   $schema['dh_feature'] = array (
    'description' => 'Base Feature class in dh (ArcHydro: Feature)',
    'fields' => array(
      'hydroid' => array(
        'description' => 'HydroID - Primary key for Features',
        'type' => 'serial',
        'unsigned' => TRUE,
        'not null' => TRUE,
      ),
      'hydrocode' => array(
        'description' => 'HydroCode',
        'type' => 'varchar',
		    'length' => 64,
        'not null' => TRUE,
      ),
      'ftype' => array(
        'description' => 'Feature Type (monitoring well, production well, geologic structure, contour line)',
        'type' => 'varchar',
		    'length' => 64,
        'not null' => TRUE,
		    'default' => '',
      ),
      'bundle' => array(
        'description' => 'Bundle (Base Feature Class watershed, waterbody, monitoringpoint, etc)',
        'type' => 'varchar',
		    'length' => 64,
        'not null' => TRUE,
		    'default' => '',
      ),
      'name' => array(
        'description' => 'Name',
        'type' => 'varchar',
		    'length' => 255,
        'not null' => TRUE,
      ),
      'fstatus' => array(
        'description' => 'Feature Status (0-unk,1-active,2-oos/temp,3-abandoned)',
        'type' => 'varchar',
		    'length' => 32,
        'not null' => FALSE,
        'default' => 'active',
      ),
      'uid' => array(
        'description' => 'Record Owner',
			  'type' => 'int',
			  'not null' => FALSE,
			  'size' => 'big',
      ),
   ) + entity_exportable_schema_fields(),
   'primary key' => array('hydroid'),
	'indexes' => array(
	   'dh_fe_hyix'      => array('hydroid'),
	   'dh_fe_ftix'        => array('bundle')
		)
   );
	
	// Table Desc for: HydrogeologicUnit
	// Relationships: AquiferID, HorizonID
	// HydroID sequence linked later in dh_install()
	$schema['dh_hydrogeologicunit'] = array (
		'description' => 'Hydrogeologic Unit table in dh (ArcHydro: HydrogeologicUnit)',
		'fields' => array(
			'hydroid' => array(
			  'description' => 'Primary key for Variables',
			  'type' => 'serial',
			  'unsigned' => TRUE,
			  'not null' => TRUE,
			),
			'hgucode'	=> array(
				'description' => 'Hydrogeologic unit code. The permanent identification code of hydrogeologic units, used to establish a linkage with external information systems.',
				'type' => 'varchar',
				'length' => 64,
				'not null' => TRUE,
				'default' => '',
			),
			'hguname'	=> array(
				'description' => 'Text descriptor of hydrogeologic units used for labeling and symbolization.',
				'type' => 'varchar',
				'length' => 64,
				'not null' => TRUE,
				'default' => '',
			),
			'aqcode'	=> array(
				'description' => 'Aquifer code. Text descriptor of the aquifer used for labeling, symbolization, and querying.',
				'type' => 'varchar',
				'length' => 64,
				'not null' => FALSE,
				'default' => '',
			),
			'hydrocode'	=> array(
				'description' => 'Text field to associate with external data source.',
				'type' => 'varchar',
				'length' => 64,
				'not null' => TRUE,
				'default' => '',
			),
			'description'	=> array(
				'description' => 'Text for storing detailed descriptions of hydrogeologic units.',
				'type' => 'varchar',
				'length' => 255,
				'not null' => FALSE,
				'default' => '',
			),
		) + entity_exportable_schema_fields(),
		'primary key' => array('hydroid'),
		'indexes' => array(
			'dh_hgu_hiix'      => array('hydroid'),
			'dh_hgu_hgix'      => array('hgucode'),
			'dh_hgu_aqix'      => array('aqcode'),
		)
	);
   // 
  $schema['dh_boreholelog_type'] = array (
    'description' => 'Base Feature class in dh (ArcHydro: Feature)',
    'fields' => array(
      'bhltid' => array(
        'description' => 'Primary key for Borehole Types',
        'type' => 'serial',
        'unsigned' => TRUE,
        'not null' => TRUE,
      ),
      'name' => array(
        'description' => 'Borehole Type Descriptive Name (Well Interval, etc.)',
        'type' => 'varchar',
		    'length' => 64,
        'not null' => TRUE,
		    'default' => '',
      ),
      'bundle' => array(
        'description' => 'Feature Type / Bundle (well_interval, ...)',
        'type' => 'varchar',
		    'length' => 64,
        'not null' => TRUE,
		    'default' => '',
      ),
      'description' => array(
        'description' => 'Description of this Borehole Class',
        'type' => 'varchar',
		    'length' => 255,
        'not null' => TRUE,
		    'default' => '',
      ),
    ) + entity_exportable_schema_fields(),
     'primary key' => array('bhltid'),
	   'indexes' => array(
	   'dh_fet_fix'      => array('bhltid'),
	   'dh_fet_ftix'     => array('bundle')
	  )
  );
	// Table Desc for: BoreholeLog
	// Relationships: WellID, HGUID, logtype
   $schema['dh_boreholelog'] = array (
		'description' => 'Borehole Log in dh (ArcHydro: BoreholeLog)',
		'fields' => array(
			'bhlid' => array(
			  'description' => 'Primary key for Variables',
			  'type' => 'serial',
			  'unsigned' => TRUE,
			  'not null' => TRUE,
			),
      'bundle' => array(
        'description' => 'Bundle (Base class well_interval, ...)',
        'type' => 'varchar',
		    'length' => 64,
        'not null' => TRUE,
		    'default' => 'dh_boreholelog',
      ),
			'fromdepth' =>  array(
			  'description' =>  'The top elevation of an interval measured as depth along the borehole.',
			  'type' => 'float',
			  'not null' => FALSE,
			),
			'todepth' =>  array(
			  'description' => 'The bottom elevation of an interval measured as depth along the borehole.',
			  'type' => 'float',
			  'not null' => FALSE,
			),
			'topelev' =>  array(
			  'description' => 'Top elevation of an interval represented in absolute elevation units (e.g., feet above mean sea level).',
			  'type' => 'float',
			  'not null' => FALSE,
			),
			'bottomelev' =>  array(
			  'description' => 'Bottom elevation of an interval represented in absolute elevation units (e.g., feet above mean sea level).',
			  'type' => 'float',
			  'not null' => FALSE,
			),
			'refelev' =>  array(
			  'description' => 'Reference Elevation',
			  'type' => 'float',
			  'not null' => FALSE,
			),
			'material'	=> array(
				'description' => 'Description of strata observed along a borehole. Usually documented in drilling logs and later classified into geologic/hydrogeologic units.',
				'type' => 'varchar',
				'length' => 255,
				'not null' => FALSE,
				'default' => '',
			),
			'hgucode'	=> array(
				'description' => 'Hydrogeologic unit code. Text for classifying, symbolizing, and labeling hydrogeologic units. (External)',
				'type' => 'varchar',
				'length' => 255,
				'not null' => FALSE,
				'default' => '',
			),
			'hguid' => array(
				'description' => 'Link to ID column of table geologic/hydrogeologic units.',
				'type' => 'int',
				'size' => 'big',
				'not null' => FALSE,
			),
			'logtype' => array(
				'description' => 'Distinguishes between types of borehole logs (e.g., well completion, hydrostratigraphy).',
				'type' => 'int',
				'size' => 'big',
				'not null' => FALSE,
			),
			'ftype' => array(
			  'description' => 'Feature Type (grout, screen, casing)',
			  'type' => 'varchar',
			  'length' => 64,
			  'not null' => FALSE,
			  'default' => '',
			),
			'diameter' =>  array(
			  'description' => 'Well diameter (in).',
			  'type' => 'float',
			  'not null' => FALSE,
			),
			'elevunits'	=> array(
				'description' => 'Units of elevations stored in the TopElev and BottomElev attributes.',
				'type' => 'varchar',
				'length' => 32,
				'not null' => FALSE,
				'default' => '',
			)
		) + entity_exportable_schema_fields(),
		'primary key' => array('bhlid'),
		'indexes' => array(
			'dh_bhl_bix'      => array('bhlid'),
		)
	);
	// this table may be no longer used in favor of the "VariableDefinition" tablE
	// even though this provides a richer set of information and could be useful?
   $schema['dh_tstype'] = array (
    'description' => 'Data Dictionary for Variables in dh (ArcHydro: TSTYPE)',
    'fields' => array(
      'tstypeid' => array(
        'description' => 'Primary key for Variables',
        'type' => 'serial',
        'unsigned' => TRUE,
        'not null' => TRUE,
      ),
      'variable' => array(
        'description' => 'Variable Name',
        'type' => 'varchar',
		    'length' => 128,
        'not null' => TRUE,
      ),
      'units' => array(
        'description' => 'Unit of Measure',
        'type' => 'varchar',
		    'length' => 32,
        'not null' => TRUE,
		    'default' => '',
      ),
      'isregular' => array(
        'description' => 'Is Regular?',
        'type' => 'int',
        'size' => 'tiny',
        'not null' => TRUE,
        'default' => 1,
      ),
      'tsinterval' => array(
        'description' => 'Interval Type',
        'type' => 'int',
        'not null' => TRUE,
        'default' => 1,
        'size' => 'tiny',
        'not null' => TRUE,
      ),
      'datatype' => array(
        'description' => 'Data Type (ArcHydro: TSDataType)',
        'type' => 'int',
        'not null' => TRUE,
        'default' => 1,
        'size' => 'tiny',
        'not null' => TRUE,
      ),
      'origin' => array(
        'description' => 'Origin (ArcHydro: TSOrigins (1 = Recorded, 2 = Generated)',
        'type' => 'int',
        'not null' => TRUE,
        'default' => 1,
        'size' => 'tiny',
        'not null' => TRUE,
      )
   ) + entity_exportable_schema_fields(),
   'primary key' => array('tstypeid'),
	'indexes' => array(
	   'dh_tst_tstix'      => array('tstypeid'),
	   'dh_tst_vix'        => array('variable')
	)
  );
  
	// VariableDefinition
	// Extra Fields:
		// Vocabulary	 Text	 Name of the list of variables in which a particular VarCode is defined (e.g., USGS NWIS).
		// need to do this as a reference, not a text field
		// Medium	 Text	 Medium in which the variable is observed or occurs (e.g., "Groundwater“)-
   $schema['dh_variabledefinition'] = array (
		'description' => 'Data Dictionary for Variables in dh (ArcHydro: TSTYPE)',
		'fields' => array(
			'hydroid' => array(
			  'description' => 'Primary key for Variables',
			  'type' => 'serial',
			  'unsigned' => TRUE,
			  'not null' => TRUE,
			),
			'varname' => array(
			  'description' => 'The name of the variable.',
			  'type' => 'varchar',
			  'length' => 128,
			  'not null' => TRUE,
			),
			'vardesc' => array(
			  'description' => 'The description of the variable.',
			  'type' => 'varchar',
			  'length' => 255,
			  'not null' => TRUE,
			  'default' => '',
			),
			'vocabulary' => array(
			  'description' => 'Name of the list of variables in which a particular VarCode is defined (e.g., USGS NWIS).',
			  'type' => 'varchar',
			  'length' => 255,
			  'not null' => TRUE,
			  'default' => '',
			),
			'varunits' => array(
			  'description' => 'Units of measure for the variable.',
			  'type' => 'varchar',
			  'length' => 32,
			  'not null' => TRUE,
			  'default' => '',
			),
			'varkey' => array(
			  'description' => 'Unique text ID for a variable, used when a variable is indexed in an attribute series table via field names.',
			  'type' => 'varchar',
			  'length' => 32,
			  'not null' => TRUE,
			  'default' => '',
			),
			'multiplicity' => array(
			  'description' => 'How to handle multiples - default tstime for timeseries, name for properties.',
			  'type' => 'varchar',
			  'length' => 64,
			  'not null' => TRUE,
			  'default' => '',
			),
			'varabbrev' => array(
			  'description' => 'Abbreviation for use in small format displays.',
			  'type' => 'varchar',
			  'length' => 32,
			  'not null' => FALSE,
			  'default' => '',
			),
			'datatype' => array(
			  'description' => 'Describes whether the time series contains instantaneous measurements, cumulative values, etc.',
			  'type' => 'varchar',
			  'length' => 32,
			  'not null' => TRUE,
			  'default' => '',
			), 
			'data_entry' => array(
			  'description' => 'Describes which form fields to show and their format, comma delimited options: numeric,text,boolean,index,date_start, date_end.',
			  'type' => 'varchar',
			  'length' => 255,
			  'not null' => FALSE,
			  'default' => '',
			), 
			'varcode' => array(
			  'description' => 'Public identifier for a variable (e.g., "00060" for discharge in USGS NWIS).',
			  'type' => 'varchar',
			  'length' => 32,
			  'not null' => TRUE,
			  'default' => '',
			), 
			'isregular' => array(
			  'description' => 'Integer field that stores 1 (TRUE) if the time series values are regularly spaced in time, or 0 (FALSE) if the time series is irregular.',
			  'type' => 'int',
			  'not null' => TRUE,
			  'default' => 1,
			  'size' => 'tiny',
			  'not null' => TRUE,
			), 
			'timestep' => array(
			  'description' => 'For regular time series, the number of TimeUnits between each occurrence of a time series value.',
			  'type' => 'int',
			  'not null' => TRUE,
			  'default' => 1,
			  'size' => 'big',
			  'not null' => TRUE,
			), 
			'timeunits' => array(
			  'description' => 'For regular time series, the time unit used to describe the length of time between occurrences of a time series value.',
			  'type' => 'varchar',
			  'length' => 32,
			  'not null' => TRUE,
			  'default' => '',
			), 
			'nodataval' => array(
			  'description' => 'Numerical value used to indicate a "No Data Value" (e.g., a missing value) in the time series table.',
			  'type' => 'int',
			  'not null' => TRUE,
			  'default' => 1,
			  'size' => 'big',
			  'not null' => TRUE,
			),
      'plugin' => array(
        'description' => 'Plugin (different bundles may have multiple plugin options)',
        'type' => 'varchar',
		    'length' => 64,
        'not null' => TRUE,
		    'default' => 'dHVariablePluginDefault',
      ),
      'options' => array(
        'description' => 'The options for this source (option settings vary by source type).',
        'type' => 'text',
        'serialize' => TRUE,
      ),
		) + entity_exportable_schema_fields(),
		'primary key' => array('hydroid'),
		'indexes' => array(
			'dh_vd_vix' => array('hydroid'),
			'dh_vd_vnix' => array('varname'),
			'dh_vd_vkix' => array('varkey'),
		)
	);
	// Table Desc for: TimeSeries
	// Relationships: FeatureID (dh_feature:hydroid)
	//   these relationships can be kept on table, and use custom Views settings to connect?
	//   the only difficulty is populating them for new entries from forms, but that is workable?
	$schema['dh_timeseries'] = array (
    'description' => 'Time Series Data in dh (ArcHydro: timeseries)',
    'fields' => array(
      'tid' => array(
        'description' => 'Primary key for Variables',
        'type' => 'serial',
        'unsigned' => TRUE,
        'not null' => TRUE,
      ),
      'tstime' =>  array(
        'description' =>  'Timestamp for monitored value.',
          'type' => 'int',
          'not null' => TRUE,
          'default' => 1,
          'size' => 'big',
      ),
      'utcoffset' =>  array(
        'description' => 'UTC Offset for timestamp.',
          'type' => 'int',
          'not null' => TRUE,
          'default' => 0,
          'size' => 'big',
      ),
			'tscode' => array(
			  'description' => 'Short text fragment value.',
			  'type' => 'varchar',
			  'length' => 32,
			  'not null' => FALSE,
			  'default' => NULL,
			), 
      'tsvalue' =>  array(
        'description' => 'The numerical value itself.',
        'type' => 'float',
        'not null' => FALSE,
			  'default' => NULL,
      ),
      'tsendtime' =>  array(
        'description' =>  'Timestamp for end time value.',
          'type' => 'int',
          'not null' => FALSE,
          'default' => 1,
          'size' => 'big',
      ),
      'entity_type' => array(
        'description' => 'Entity Type (default: dh_feature)',
        'type' => 'varchar',
        'length' => 64,
        'not null' => FALSE,
        'default' => 'dh_feature',
      ),
    //  'bundle' => array(
    //    'description' => 'Bundle (TimeSeries Class type)',
    //    'type' => 'varchar',
    //    'length' => 64,
    //    'not null' => FALSE,
    //    'default' => 'dh_timeseries',
    //`   ),
      'featureid' =>  array(
        'description' => 'Unique numerical identifier of a feature within the geodatabase. Usually, the FeatureID of a TimeSeries record is equal to the HydroID of a feature (e.g., well, monitoring point).',
        'type' => 'int',
        'not null' => TRUE,
        'default' => 1,
        'size' => 'big',
        'not null' => TRUE,
      ), 
      'varid' =>  array(
        'description' => 'Unique numerical identifier of a variable within the geodatabase. Variables are defined in the VariableDefinition table.',
        'type' => 'int',
        'not null' => TRUE,
        'default' => 1,
        'size' => 'big',
        'not null' => TRUE,
      ), 
      'timeline' => array(
        'description' => 'TimeLine ID, 1 is historical record, >1 alternative timelines/scenariod',
        'type' => 'int',
        'size' => 'tiny',
        'not null' => FALSE,
        'default' => 1,
      ),
      'modified' => array(
		    'description' =>  'Timestamp for last modified.',
			  'type' => 'int',
			  'not null' => FALSE,
			  'size' => 'big',
      ),
      'uid' => array(
        'description' => 'Record Owner',
			  'type' => 'int',
			  'not null' => FALSE,
			  'size' => 'big',
      ),
		) + entity_exportable_schema_fields(),
		'primary key' => array('tid'),
		'indexes' => array(
			'dh_ts_tix' => array('tid'),
			'dh_ts_fix' => array('featureid'),
			'dh_ts_vix' => array('varid'),
			'dh_ts_tstix' => array('tstime'),
			'dh_ts_tlix' => array('timeline'),
		)
	);
	// Table Desc for: Properties
  $schema['dh_properties_type'] = array (
    'description' => 'Base Feature class in dh (ArcHydro: Feature)',
    'fields' => array(
      'ptid' => array(
        'description' => 'Primary key for Property Types',
        'type' => 'serial',
        'unsigned' => TRUE,
        'not null' => TRUE,
      ),
      'name' => array(
        'description' => 'Type Descriptive Name (Well Interval, etc.)',
        'type' => 'varchar',
		    'length' => 64,
        'not null' => TRUE,
		    'default' => '',
      ),
      'bundle' => array(
        'description' => 'Feature Type / Bundle (dh_properties, stream_channel, ...)',
        'type' => 'varchar',
		    'length' => 64,
        'not null' => TRUE,
		    'default' => '',
      ),
      'description' => array(
        'description' => 'Description of this Borehole Class',
        'type' => 'varchar',
		    'length' => 255,
        'not null' => TRUE,
		    'default' => '',
      ),
    ) + entity_exportable_schema_fields(),
     'primary key' => array('ptid'),
	   'indexes' => array(
	   'dh_pt_ptix'      => array('ptid'),
	   'dh_pt_bix'     => array('bundle')
	  )
  );
  // Custom extension to dH for storing non-temporal or semi-static parameters
	// Relationships: FeatureID (dh_feature:hydroid)
  $schema['dh_properties'] = array (
    'description' => 'Properties table in dh',
    'fields' => array(
      'pid' => array(
        'description' => 'Primary key for Variables',
        'type' => 'serial',
        'unsigned' => TRUE,
        'not null' => TRUE,
      ),
      'propname' =>  array(
        'description' => 'The numerical value itself.',
          'type' => 'varchar',
          'length' => 255,
          'not null' => TRUE,
          'default' => '',
      ),
      'propvalue' =>  array(
        'description' => 'The numerical value itself.',
        'type' => 'numeric',
        'not null' => FALSE,
      ),
      'propcode' => array(
        'description' => 'Short text fragment value.',
        'type' => 'varchar',
        'length' => 255,
        'not null' => FALSE,
        'default' => NULL,
      ), 
      'startdate' => array(
        'description' => 'Start Date',
        'type' => 'int',
        'not null' => FALSE,
        'size' => 'big',
      ),
      'enddate' => array(
        'description' => 'End Date',
        'type' => 'int',
        'not null' => FALSE,
        'size' => 'big',
      ),				
      'featureid' =>  array(
        'description' => 'Unique numerical identifier of a feature within the geodatabase. Usually, the FeatureID of a TimeSeries record is equal to the HydroID of a feature (e.g., well, monitoring point).',
        'type' => 'int',
        'not null' => TRUE,
        'default' => 1,
        'size' => 'big',
        'not null' => TRUE,
      ), 
      'modified' => array(
		    'description' =>  'Timestamp for last modified.',
			  'type' => 'int',
			  'not null' => FALSE,
			  'size' => 'big',
      ),
      // not ready to implement just yet
      'entity_type' => array(
        'description' => 'Entity Type (default: dh_feature)',
        'type' => 'varchar',
        'length' => 64,
        'not null' => FALSE,
        'default' => 'dh_feature',
      ),
      'bundle' => array(
        'description' => 'Bundle (Base Property Class property)',
        'type' => 'varchar',
        'length' => 64,
        'not null' => FALSE,
        'default' => 'dh_properties',
      ),
      'varid' =>  array(
        'description' => 'Unique numerical identifier of a variable within the geodatabase. Variables are defined in the VariableDefinition table.',
        'type' => 'int',
        'not null' => TRUE,
        'default' => 1,
        'size' => 'big',
        'not null' => TRUE,
      ), 
      'uid' => array(
        'description' => 'Record Owner',
			  'type' => 'int',
			  'not null' => FALSE,
			  'size' => 'big',
      ),
      'vid' => array(
        'description' => 'The current {dh_properties}.vid version identifier.',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => FALSE,
        'default' => NULL,
      ),
	) + entity_exportable_schema_fields(),
	'primary key' => array('pid'),
	'indexes' => array(
		'dh_ps_tix' => array('pid'),
		'dh_ps_pnix' => array('propname'),
		'dh_ps_fix' => array('featureid'),
		'dh_ps_vix' => array('varid'),
	)
  );
  
  // Custom extension to dH for storing non-temporal or semi-static parameters
	// Relationships: FeatureID (dh_feature:hydroid)
	$schema['dh_properties_revision'] = array (
    'description' => 'Properties table in dh',
    'fields' => array(
      'vid' => array(
        'description' => 'The current {dh_properties}.vid version identifier.',
        'type' => 'serial',
        'unsigned' => TRUE,
        'not null' => TRUE,
      ),
      'pid' => array(
        'description' => 'Primary key for Properties',
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
      ),
      'propname' =>  array(
        'description' => 'The numerical value itself.',
          'type' => 'varchar',
          'length' => 64,
          'not null' => TRUE,
          'default' => '',
      ),
      'propcode' => array(
        'description' => 'Short text fragment value.',
        'type' => 'varchar',
        'length' => 32,
        'not null' => FALSE,
        'default' => NULL,
      ), 
      'propvalue' =>  array(
        'description' => 'The numerical value itself.',
        'type' => 'numeric',
        'not null' => FALSE,
      ),
      'startdate' => array(
        'description' => 'Start Date',
        'type' => 'int',
        'not null' => FALSE,
        'size' => 'big',
      ),
      'enddate' => array(
        'description' => 'End Date',
        'type' => 'int',
        'not null' => FALSE,
        'size' => 'big',
      ),				
      'featureid' =>  array(
        'description' => 'Unique numerical identifier of a feature within the geodatabase. Usually, the FeatureID of a TimeSeries record is equal to the HydroID of a feature (e.g., well, monitoring point).',
        'type' => 'int',
        'not null' => TRUE,
        'default' => 1,
        'size' => 'big',
        'not null' => TRUE,
      ), 
      // not ready to implement just yet
      'entity_type' => array(
        'description' => 'Entity Type (default: dh_feature)',
        'type' => 'varchar',
        'length' => 64,
        'not null' => FALSE,
        'default' => 'dh_feature',
      ),
      'bundle' => array(
        'description' => 'Bundle (Base Property Class property)',
        'type' => 'varchar',
        'length' => 64,
        'not null' => FALSE,
        'default' => 'dh_properties',
      ),
      'varid' =>  array(
        'description' => 'Unique numerical identifier of a variable within the geodatabase. Variables are defined in the VariableDefinition table.',
        'type' => 'int',
        'not null' => TRUE,
        'default' => 1,
        'size' => 'big',
        'not null' => TRUE,
      ), 
      'uid' => array(
        'description' => 'Record Owner',
			  'type' => 'int',
			  'not null' => FALSE,
			  'size' => 'big',
      ),
    ) + entity_exportable_schema_fields(),
    'primary key' => array('vid'),
    'indexes' => array(
      'dh_psr_rvix' => array('vid'),
      'dh_ps_pnix' => array('propname'),
      'dh_psr_tix' => array('pid'),
      'dh_psr_fix' => array('featureid'),
      'dh_psr_vix' => array('varid'),
    )
  );
  
  
  return $schema;
}

function dh_uninstall() {
  $fields = array('dh_geofield', 'wellid', 'hguid', 'dh_welldepth', 'dh_landelev',  'dh_lengthkm', 'dh_usgs_site_no', 'dh_areasqkm', 'dh_fips', 'proptext', 'aquiferid');
	
  foreach ($fields as $field) {
    drupal_set_message("Removing field '$field'");
	  $numd = 0;
    while (!(field_info_field($field) === NULL)) {
      field_delete_field($field);
      $numd++;
      if ($numd < 10) {
        drupal_set_message("Loop detected - exiting");
        break;
      }
	  }
    drupal_set_message("Deleted $numd fields");
  }
}

function dh_install() {

	// set links to sequence for non-feature tables that 
	// need a global hydroid
	// note that we use the Drupal "{tablename}" to allow
	// Drupal to add a prefix to our table name if the install
	// is using prefixes (allows for multisite)
	// but when we do the alter table, this may fail 
	// with prefixes because the prefix is probably also
	// added to the sequence name dh_feature_hydroid_seq
	// may need to process that also (not sure how)
	//$hydroid_tables = array('dh_hydrogeologicunit');
	$hydroid_tables = array();
	foreach ($hydroid_tables as $thistable) {
		if (db_table_exists($thistable)) {
			db_query("alter table {$thistable} alter column hydroid set default nextval('dh_feature_hydroid_seq'::regclass)");
		}
	}
   // add geometry columns to all feature classes
  dh_addGeometry('dh_feature');
	dh_add_bundles();
	dh_add_references();
  dh_boreholelog_add_bundles();
  dh_properties_add_bundles();
	dh_initialize_fields('dh_properties', 'proptext', 'dh_properties');  
}

function dh_add_bundles() {
  $typedefs = dh_define_bundles();

	foreach ($typedefs as $key => $thistype) {
		dh_base_feature_type_save($thistype);
	   dh_initialize_fields($key);
	}

}

function dh_boreholelog_add_bundles() {
  $bhl_types = dh_define_boreholelog_bundles();
  foreach ($bhl_types as $thistype) {
    if ($e = entity_create('dh_boreholelog_type', $thistype)) {
      $e->save();
    }
  }
  
}
function dh_define_boreholelog_bundles() {
  $typedefs = array(
    'dh_boreholelog' => array('bundle' => 'dh_boreholelog', 'name' => 'Default Borehole Log Type', 'description' => 'dH Basic Borehole Interval'),
    'well_interval' => array('bundle' => 'well_interval', 'name' => 'Well Interval', 'description' => 'dH Basic Groundwater Well Interval'),
  );
  return $typedefs;
}

function dh_properties_add_bundles() {
  $bhl_types = dh_define_properties_bundles();
  foreach ($bhl_types as $thistype) {
    if ($e = entity_create('dh_properties_type', $thistype)) {
      $e->save();
    }
  }
  
}
function dh_define_properties_bundles() {
  $typedefs = array(
    'dh_properties' => array('bundle' => 'dh_properties', 'name' => 'Default Properties Type', 'description' => 'dH Properties Default'),
  );
  return $typedefs;
}

function dh_define_bundles() {
  $typedefs = array(
    'well' => array('bundle' => 'well', 'name' => 'Well', 'description' => 'dH Basic Groundwater Well Feature'),
    'intake' => array('bundle' => 'intake', 'name' => 'Surface Water Intake', 'description' => 'dH Basic Surface Water Intake Feature'),
    'aquifer' => array('bundle' => 'aquifer', 'name' => 'Aquifer', 'description' => 'dH Basic Aquifer Feature'),
    'monitoringpoint' => array('bundle' => 'monitoringpoint', 'name' => 'MonitoringPoint', 'description' => 'dH Basic Monitoring Point Feature'),
    'waterpoint' => array('bundle' => 'waterpoint', 'name' => 'WaterPoint', 'description' => 'dH Basic Water Point Feature'),
    'waterline' => array('bundle' => 'waterline', 'name' => 'WaterLine', 'description' => 'dH Basic Water Line Feature'),
    'waterbody' => array('bundle' => 'waterbody', 'name' => 'WaterBody', 'description' => 'dH Basic Water Body Feature'),
    'watershed' => array('bundle' => 'watershed', 'name' => 'Watershed', 'description' => 'dH Basic Watershed Feature'),
    'borepoint' => array('bundle' => 'borepoint', 'name' => 'BorePoint', 'description' => 'dH Basic Borepoint Feature'),
    'boreline' => array('bundle' => 'boreline', 'name' => 'BoreLine', 'description' => 'dH Basic Boreline Feature'), 
    'usgsgage' => array('bundle' => 'usgsgage', 'name' => 'USGSGage', 'description' => 'dH Basic USGS Gage Feature'), 
    'usafips' => array('bundle' => 'usafips', 'name' => 'USAFips', 'description' => 'dH USA FIPS Political Boundaries'), 
    'landunit' => array('bundle' => 'landunit', 'name' => 'Land Unit', 'description' => 'dH Land Unit'),
	);
  return $typedefs;
}

function dh_base_feature_type_save($info) {
  // set the base dh_feature_type entries
  // modeled after node_type_save
  $existing_type = !empty($info['old_bundle']) ? $info['old_bundle'] : $info['bundle'];
  $is_existing = (bool) db_query_range('SELECT 1 FROM {dh_feature_type} WHERE bundle = :bundle', 0, 1, array(':bundle' => $existing_type))->fetchField();

  $fields = array(
    'bundle' => $info['bundle'],
    'name' => $info['name'],
    'description' => $info['description'],
  );

  if ($is_existing) {
    db_update('dh_feature_type')
      ->fields($fields)
      ->condition('bundle', $existing_type)
      ->execute();

    if (!empty($info['old_bundle']) && $info['old_bundle'] != $info['bundle']) {
      field_attach_rename_bundle('dh_feature', $info['old_bundle'], $info['bundle']);
    }
	 // need equivalent?
    //module_invoke_all('node_type_update', $type);
    $status = SAVED_UPDATED;
  }
  else {
    db_insert('dh_feature_type')
      ->fields($fields)
      ->execute();

    field_attach_create_bundle('dh_feature', $info['bundle']);

    $status = SAVED_NEW;
  }

  // Clear the node type cache.
  // hmmm ... do we need to supply an equivalent to this?
  // node_type_cache_reset();
  dh_feature_type_cache_reset();

  return $status;
}

function dh_initialize_fields($type, $field = '', $entity = 'dh_feature', $fields_fields = array(), $debug = 0) {
  $base_instance = array(
	 'field_name' => 'welldepth',
	 'entity_type' => $entity,
	 'bundle' => 'well',
	 'label' => 'Well Depth',
	 'settings' => array(
	 ),
	 'widget' => array(
		'type' => 'number',
		'settings'   => array('size' => 60),
	 ),
	 'display' => array(
		'full' => array(
		  'type' => 'text_default',
		),
	 ),
	);
	
  if (count($fields_fields) > 0) {
    $extra_fields = $fields_fields;
  } else {
    $extra_fields = array(
       'well' => array(
         'dh_welldepth' => array('label' => 'Well Depth', 'type' => 'numeric'),
        'dh_landelev' => array('label' => 'Land Surface Elevation','type' => 'numeric'),
        'dh_geofield' => array('label' => 'Geometry', 'type' => 'geofield', 'display' => 'geofield_wkt', 'widget' => 'geofield_wkt'),
      ),
       'intake' => array(
         'dh_areasqkm' => array('label' => 'Area km^2', 'type' => 'numeric'),
         'dh_geofield' => array('label' => 'Geometry', 'type' => 'geofield', 'display' => 'geofield_wkt', 'widget' => 'geofield_wkt'),
      ),
       'landunit' => array(
         'dh_areasqkm' => array('label' => 'Area km^2', 'type' => 'numeric'),
         'dh_geofield' => array('label' => 'Geometry', 'type' => 'geofield', 'display' => 'geofield_wkt', 'widget' => 'geofield_wkt'),
      ),
        'watershed' => array(
          'dh_areasqkm' => array('label' => 'Area km^2', 'type' => 'numeric'),
          'dh_nextdownid' => array('label' => 'Next Down HydroID', 'type' => 'numeric'),
          'dh_geofield' => array('label' => 'Geometry', 'type' => 'geofield', 'display' => 'geofield_wkt', 'widget' => 'geofield_wkt'),
      ),
       'aquifer' => array(
         'dh_geofield' => array('label' => 'Geometry', 'type' => 'geofield', 'display' => 'geofield_wkt', 'widget' => 'geofield_wkt'),
      ),
       'waterpoint' => array(
         'dh_geofield' => array('label' => 'Geometry', 'type' => 'geofield', 'display' => 'geofield_wkt', 'widget' => 'geofield_wkt'),
      ),
       'monitoringpoint' => array(
         'dh_geofield' => array('label' => 'Geometry', 'type' => 'geofield', 'display' => 'geofield_wkt', 'widget' => 'geofield_wkt'),
      ),
       'aquifer' => array(
         'dh_geofield' => array('label' => 'Geometry', 'type' => 'geofield', 'display' => 'geofield_wkt', 'widget' => 'geofield_wkt'),
      ),
       'waterline' => array(
         'dh_geofield' => array('label' => 'Geometry', 'type' => 'geofield', 'display' => 'geofield_wkt', 'widget' => 'geofield_wkt'),
         'dh_nextdownid' => array('label' => 'Next Down HydroID', 'type' => 'numeric'),
         'dh_lengthkm' => array('label' => 'Length km', 'type' => 'numeric'),
      ),
       'waterbody' => array(
         'dh_geofield' => array('label' => 'Geometry', 'type' => 'geofield', 'display' => 'geofield_wkt', 'widget' => 'geofield_wkt'),
         'dh_nextdownid' => array('label' => 'Next Down HydroID', 'type' => 'numeric'),
      ),
       'borepoint' => array(
         'dh_geofield' => array('label' => 'Geometry', 'type' => 'geofield', 'display' => 'geofield_wkt', 'widget' => 'geofield_wkt'),
      ),
       'boreline' => array(
         'dh_geofield' => array('label' => 'Geometry', 'type' => 'geofield', 'display' => 'geofield_wkt', 'widget' => 'geofield_wkt'),
      ),
       'usgsgage' => array(
         'dh_geofield' => array('label' => 'Geometry', 'type' => 'geofield', 'display' => 'geofield_wkt', 'widget' => 'geofield_wkt'),
         'dh_areasqkm' => array('label' => 'Area km^2', 'type' => 'numeric'),
         'dh_usgs_site_no' => array('label' => 'USGS Gage ID', 'type' => 'text'),
      ),
       'usafips' => array(
         'dh_geofield' => array('label' => 'Geometry', 'type' => 'geofield', 'display' => 'geofield_wkt', 'widget' => 'geofield_wkt'),
         'dh_areasqkm' => array('label' => 'Area km^2', 'type' => 'numeric'),
         'dh_fips' => array('label' => 'FIPS Code', 'type' => 'text'),
      ),
       'dh_properties' => array(
         'proptext' => array('label' => 'Storage for text properties', 'type' => 'text_long', 'max_length' => '', 'widget' => 'text_long'),
      ),
       'dh_timeseries' => array(
         'tstext' => array('label' => 'Storage for text ts value', 'type' => 'text_long', 'max_length' => '', 'widget' => 'text_long'),
         'image' => array('label' => 'Image', 'type' => 'image', 'file_extensions' => 'png gif jpg jpeg', 'widget' => 'image_image'),
      ),
    );
  }
	
	if (!isset($extra_fields[$type])) {
    drupal_set_message("Bundle $type not found in " . print_r(array_keys($extra_fields),1));
		return;
	}
	if ($field == '') {
		$fields = $extra_fields[$type];
	} else {
		$fields = array();
		$fields[$field] = $extra_fields[$type][$field];
	}
	
	foreach ($fields as $fieldname => $props) {
		$label = $props['label'];
		$fieldrecs = field_read_fields(array('field_name' => $fieldname), array('include_inactive' => TRUE) );
		if ( count($fieldrecs) == 0 ) {
	  	if ($debug) drupal_set_message(t("Initializing $fieldname " . print_r($props,1)));
			dh_initialize_field($fieldname, $props);
		}
    $instance = $base_instance;
		if (field_info_instance($entity, $fieldname, $type) === NULL) {
		   $fieldrecs = field_read_fields(array('field_name' => $fieldname), array('include_inactive' => TRUE) );
			if ( count($fieldrecs) == 0 ) {
				if ($debug) drupal_set_message(t("Failed to initialize $fieldname "));
			} else {
				$instance['field_name'] = $fieldname;
				$instance['bundle'] = $type;
				$instance['label'] = $label;
				if (isset($props['widget'])) {
				   $instance['widget']['type'] = $props['widget'];
				}
				if (isset($props['display'])) {
				   $instance['display']['full']['type'] = $props['display'];
				}
				if($fieldname == 'proptext') {
					 $instance['settings'] = array(
		      		'text_processing' => 1,
        			);
				}
		    switch ($props['type']) {
          case 'text':
          unset($instance['cardinality']);
          $instance['widget']['type'] = 'text_textfield';
		      $instance['widget']['settings'] = array('size' => 60);
          break;
          
          default:
	        $instance['cardinality'] = 1;
          break;
        }
				$fa = field_create_instance($instance);
			}
		}
	}
}


function dh_initialize_field($fieldname, $fieldinfo, $debug = false) {
  $text_field_info = text_field_info();
	switch($fieldinfo['type']) {
		case 'int':
			$thisfield = array(
				 'field_name' => $fieldname,
				 'type' => 'number_integer',
			);
			if (field_info_field($fieldname) === NULL) {
        if ($debug) drupal_set_message("calling field_create_field for " . print_r($thisfield,1));
				$res = field_create_field($thisfield);
        if ($debug) drupal_set_message("field_create_field returned $res ");
			} else {
        if ($debug) drupal_set_message("field_info_field reports $fieldname exists ");
      }
		break;

		case 'varchar_64':
			$thisfield = array(
				 'field_name' => $fieldname,
				 'type' => 'text',
			);
			$thisfield['settings'] = array('max_length' => 60);
			if (field_info_field($fieldname) === NULL) {
				field_create_field($thisfield);
			}
		break;
		case 'numeric':
			$thisfield = array(
				 'field_name' => $fieldname,
				 'type' => 'number_float',
				 'cardinality' => 1,
			);
			if (field_info_field($fieldname) === NULL) {
				field_create_field($thisfield);
			}
		break;
		case 'text':
			$thisfield = array(
				 'field_name' => $fieldname,
				 'type' => 'text',
			);
      if (isset($fieldinfo['size'])) {
        $thisfield['size'] = $fieldinfo['size'];
      } else {
        $thisfield['size'] = 60;
      }
			if (field_info_field($fieldname) === NULL) {
				field_create_field($thisfield);
			}
		break;
		case 'text_long':
			$thisfield = array(
				 'field_name' => $fieldname,
				 'type' => 'text_long',
				 'cardinality' => 1,
			);
			if (field_info_field($fieldname) === NULL) {
				field_create_field($thisfield);
			}			
		break;		
	
	}
}

function dh_addGeometry($bundle, $entity = 'dh_feature', $field_name = 'dh_geofield', $field_type = 'geofield', $widget_type = 'geofield_wkt') {

  // Create the base field
  $field = array('field_name' => $field_name, 'type' => $field_type);
  // detect postgis
  $is_postgis = false;
  //drupal_set_message("pg field field_info_field()" . print_r(field_info_field('pg'),1));
  $dbtype = Database::getConnection()->databaseType();
  switch ($dbtype) {
    case 'pgsql':
      $value = db_query('SELECT substring(PostGIS_Version() from 1 for 3)')->fetchField();
      if (!empty($value)) {
        if (module_exists('geofield_postgis')) {
          $is_postgis = true;
          $field['settings'] = Array ( 
            'backend' => 'postgis', 
            'postgis' => Array ( 
              'fieldtype' => 'geometry',
            ),
            'srid' => 4326,
          );
          drupal_set_message("Using geofield_postgis_backend_schema for field info");
        } else {
          error_log("PostGIS Geofield Not available");
          drupal_set_message("PostGIS Geofield Not available");
        }
      } else {
        error_log("PostGIS Not available on DB");
        drupal_set_message("PostGIS Not available on DB");
      }
    break;
    
    default:
      error_log("Non Postgres Database");
      drupal_set_message("Non Postgres Database");
    break;
  }
  field_create_field($field);
  if ($is_postgis) {
    db_query("create index field_data_dh_geofield_dh_geofield_geom_idx on {field_data_dh_geofield} using GIST (dh_geofield_geom)");
  }

  // Create an instance of the field and attach it to the poa day entity.
  $instance = array(
    'field_name' => $field_name,
    'entity_type' => $entity,
    'bundle' => $bundle,
    'label' => $field_name,
    'settings' => array(
    ),
    'widget' => array(
      'type' => $widget_type,
    ),
    'display' => array(
      'full' => array(
        'type' => 'geofield_wkt',
      ),
    ),
  );
  field_create_instance($instance);
}


function dh_add_references($refdefs = array(), $debug = false) {
  if (count($refdefs) == 0 ) {
    $refdefs = array();
    // Well Feature refs
    $refdefs[] = array(
      'fieldname' => 'aquiferid',
      'src_type' => 'dh_feature',
      'dest_type' => 'dh_feature',
      'src_bundle' => 'well',
      'dest_bundle' => array('aquifer'),
      'label' => 'Aquifer',
      'select_type' => 'options_select'
    );
    $refdefs[] = array(
      'fieldname' => 'hguid',
      'src_type' => 'dh_feature',
      'dest_type' => 'dh_hydrogeologicunit',
      'src_bundle' => 'well',
      'dest_bundle' => NULL,
      'label' => 'Hydrogeologic Unit',
      'select_type' => 'options_select'
    );
    $refdefs[] = array(
      'fieldname' => 'hguid',
      'src_type' => 'dh_feature',
      'dest_type' => 'dh_hydrogeologicunit',
      'src_bundle' => 'aquifer',
      'dest_bundle' => NULL,
      'label' => 'Hydrogeologic Unit',
      'select_type' => 'entityreference_autocomplete'
    );
    // Boreholelog refs
    $refdefs[] = array(
      'fieldname' => 'wellid',
      'src_type' => 'dh_boreholelog',
      'dest_type' => 'dh_feature',
      'src_bundle' => 'dh_boreholelog',
      'dest_bundle' => array('well'),
      'label' => 'Well ID',
      'select_type' => 'entityreference_autocomplete'
    );
    $refdefs[] = array(
      'fieldname' => 'hguid',
      'src_type' => 'dh_boreholelog',
      'dest_type' => 'dh_hydrogeologicunit',
      'src_bundle' => 'dh_boreholelog',
      'dest_bundle' => NULL,
      'label' => 'Hydrogeologic Unit',
      'select_type' => 'options_select'
    );
    //  Feature Managing User
    $managed = dh_define_bundles();
    foreach ($managed as $bundle => $binfo) {
      $refdefs[] = array(
        'fieldname' => 'dh_link_feature_mgr_id',
        'src_type' => 'dh_feature',
        'src_bundle' => $bundle,
        'dest_type' => 'user',
        'dest_bundle' => NULL,
        'label' => 'Link from Admin record to Managing User',
        'select_type' => 'entityreference_autocomplete'
      );
    }
    // next down ID
    $nd_bundles = array('watershed', 'waterbody', 'waterline');
    foreach ($nd_bundles as $thisbundle) { 
      $refdefs[] = array(
        'fieldname' => 'dh_nextdown_id',
        'src_type' => 'dh_feature',
        'src_bundle' => $bundle,
        'dest_type' => 'dh_feature',
        'dest_bundle' => array('watershed', 'waterbody', 'waterline'),
        'label' => 'Link from one feature to a receiving feature in the flow network',
        'select_type' => 'entityreference_autocomplete'
      );
    }
  }

  foreach ($refdefs as $def) {
    drupal_set_message("Creating link from " . $def['src_type'] . " to type " . $def['dest_type'] );
    dh_create_reference ($def['fieldname'], $def['src_type'], $def['dest_type'], $def['src_bundle'], $def['dest_bundle'], $def['label'], $def['select_type'], $debug);
  }
}


function dh_create_reference ($fieldname, $src_type, $dest_type, $src_bundle, $dest_bundle, $label = '', $select_type = 'options_select', $debug = false) {
  if ($debug) {
    drupal_set_message("dh_create_reference ($fieldname, $src_type, $dest_type, " . print_r($src_bundle,1) . ", " . print_r($dest_bundle,1) . ", $label = '', $select_type = 'options_select')");
  }
	if ($label == '') $label = $fieldname;
  $field = array(
    'field_name' => $fieldname,
    'type' => 'entityreference',
    'cardinality' => FIELD_CARDINALITY_UNLIMITED,
    'settings' => array(
      'target_type' => $dest_type,
      'handler_settings' => array('target_bundles' => $dest_bundle),
    ),
  );
  if ($debug) {
    drupal_set_message("Checking for EREF field name $fieldname ");
	}
  $fieldrecs = field_read_fields(array('field_name' => $fieldname), array('include_inactive' => TRUE) );
	if ( count($fieldrecs) == 0 ) {
    if ($debug) { drupal_set_message("Not found, creating EREF $fieldname "); }
		field_create_field($field);
	}
  
  $instance = array(
    'field_name' => $fieldname,
    'entity_type' => $src_type,
    'bundle' => $src_bundle,
    'label' => $label,
    'widget' => array(
      'type' => $select_type,
    ),
    'settings' => array(
      'target_type' => $dest_type,
      'handler_settings' => array('target_bundles' => $dest_bundle),
    ),
  );
  drupal_set_message("Not found, creating EREF $fieldname " . print_r($instance,1));
  field_create_instance($instance);
}

function dh_create_default_views() {
   //$q = "  ";
   //$result = db_query($q);
}

function dh_feature_type_cache_reset() {
  cache_clear_all('dh_feature_type:', 'cache', TRUE);
  //drupal_static_reset('_node_types_build');
}


function dh_update_7101() {
   dh_initialize_fields('waterline', 'dh_lengthkm');
	error_log("Adding waterline lengthkm");
}

function dh_update_7102() {
	db_query("alter table {dh_variabledefinition} rename column varid to hydroid ");
	drupal_set_message(t("Renamed column varid to hydroid"));
	db_query("alter table {dh_variabledefinition} add column vocabulary varchar(255) ");
	drupal_set_message(t("Added column vocabulary to dh_variabledefinition."));
}

function dh_update_7103() {
	db_query("alter table {dh_timeseries} alter column tstime type bigint ");
	drupal_set_message(t("Reformatted Timeseries time column."));
}

function dh_update_7105() {
	$usgs = array('bundle' => 'usgsgage', 'name' => 'USGSGage', 'description' => 'dH Basic USGS Gage Feature');
	dh_base_feature_type_save($usgs);
   dh_initialize_fields('usgsgage');
}

function dh_update_7106() {
	db_query("alter table {field_data_dh_geofield} alter column dh_geofield_srid set default 4326 ");
	db_query("update {field_data_dh_geofield} set dh_geofield_srid = 4326 where dh_geofield_srid is null");
	drupal_set_message(t("Set and initialized default on dh_geofield srid column."));
}

function dh_update_7107() {
   dh_initialize_fields('usgsgage', 'dh_usgs_site_no');
}

function dh_update_7108() {
	drupal_set_message(t("Adding United States Political Boundaries Feature Support."));
	$usafips = array('bundle' => 'usafips', 'name' => 'USAFips', 'description' => 'dH USA FIPS Political Boundaries');
	dh_base_feature_type_save($usafips);
     dh_initialize_fields('usafips');
}

function dh_update_7109() {
	drupal_set_message(t("Adding Spatial and Area field to United States Political Boundaries Feature Support."));
     dh_initialize_fields('usafips');
}

function dh_update_7111() {
	drupal_set_message(t("Adding FIPS Code field to United States Political Boundaries Feature Support."));
     dh_initialize_fields('usafips');
}

function dh_update_7112() {
  drupal_set_message(t("Updating default formatters for dH Fields and Instances."));
  $fields = array('dh_welldepth', 'dh_landelev', 'dh_areasqkm', 'dh_lengthkm', 'dh_usgs_site_no', 'dh_fips');
  $feature_entity = entity_get_info('dh_feature');
  foreach ($feature_entity['bundles'] as $bundle => $binfo) {
    foreach ($fields as $field) {
      $instance_info = field_info_instance('dh_feature', $field, $bundle);
      if ($instance_info) {
        drupal_set_message(t("Updating widget for $field on $bundle"));
        $instance_info['widget'] = array(
		'type' => 'text',
		'settings'   => array('size' => 60),
        );
        // Write the changed definition back.
        field_update_instance($instance_info);
      }
    }
  }   
}
function dh_update_7113() {
  $schema = dh_schema();
  db_create_table('dh_properties', $schema['dh_properties']);
  drupal_set_message(t("Added schema for dh_properties table."));
}
  
function dh_update_7114() {
  db_query("alter table {dh_properties} rename column tsvalue to propvalue ");
//  db_query("alter table {dh_properties} add column proptext text ");
  
  drupal_set_message(t("Added schema for dh_properties table."));
  // add new proptext field
  dh_initialize_fields('dh_properties', 'proptext', 'dh_properties');
}
 
function dh_update_7115() {
  dh_initialize_fields('dh_properties', 'proptext', 'dh_properties');
} 
  
function dh_update_7116() {
  dh_initialize_fields('dh_properties', 'proptext', 'dh_properties');
}  

function dh_update_7117() {
  field_delete_field('dh_properties');
  field_delete_field('proptext');
  dh_initialize_fields('dh_properties', 'proptext', 'dh_properties');  
}    

function dh_update_7118() {
  drupal_set_message(t("Updating default formatters for dH Fields and Instances."));
  $type = 'text';
  $fields = array('dh_feature' => 'dh_usgs_site_no', 'dh_feature' => 'dh_fips', 'dh_properties' => 'proptext');
  foreach ($fields as $entity_type => $field) {
    $feature_entity = entity_get_info($entity_type);
	if($entity_type == 'dh_properties') {
      $feature_entity['bundles'] = array('dh_properties' => array());
	  $type = 'text_long';
	  $size = '';
	} else {
		$type = 'text_textfield';
		$size = '60';
	}
    foreach ($feature_entity['bundles'] as $bundle => $binfo) {
      $instance_info = field_info_instance($entity_type, $field, $bundle);
      if ($instance_info) {
        drupal_set_message(t("Updating widget for $field on $bundle"));
        $instance_info['widget'] = array(
		      'type' => $type,
		      'settings'   => array('size' => $size),
        );
        // Write the changed definition back.
        field_update_instance($instance_info);
      }
    }
  }  
}  

function dh_update_7121() {
  drupal_set_message(t("Updating default formatters for dH Text Fields."));
  $type = 'text';
  $fields = array();
  $fields[] = array('entity' => 'dh_feature', 'field' => 'dh_usgs_site_no');
  $fields[] = array('entity' => 'dh_feature', 'field' => 'dh_fips');
  foreach ($fields as $thisfield) {
    $entity_type = $thisfield['entity'];
    $field = $thisfield['field'];
    $feature_entity = entity_get_info($entity_type);
	  $type = 'text_textfield';
    $size = '60';
    foreach ($feature_entity['bundles'] as $bundle => $binfo) {
      $instance_info = field_info_instance($entity_type, $field, $bundle);
      if ($instance_info) {
        drupal_set_message(t("Updating widget for $field on $bundle"));
        $instance_info['widget'] = array(
		      'type' => $type,
		      'settings'   => array('size' => $size),
        );
        // Write the changed definition back.
        field_update_instance($instance_info);
      }
    }
  }  
}  

function dh_update_7122() {
  drupal_set_message(t("Updating dH Prop Table to have propname field."));
  db_query("alter table {dh_properties} add column propname varchar(64) ");
  
  drupal_set_message(t("Added schema for dh_properties table."));
  // add new proptext field
  dh_initialize_fields('dh_properties', 'propname', 'dh_properties');
}  

function dh_update_7123() {
  //add startdate and endate to dh Properties schema
  $startdate = array(
    'description' => 'Start Date',
	  'type' => 'int',
	  'not null' => FALSE,
	  'size' => 'big',
  );
  db_add_field( 'dh_properties', 'startdate', $startdate);

  $enddate = array(
    'description' => 'End Date',
	  'type' => 'int',
	  'not null' => FALSE,
	  'size' => 'big',
  );
  db_add_field( 'dh_properties', 'enddate', $enddate);
}

function dh_update_7124() {
  // add the surface water intake bundle
  dh_add_bundles(array('intake'));
}

function dh_update_7125() {
	drupal_set_message(t("Adding base fields to intake bundle."));
  dh_initialize_fields('intake');
}

function dh_update_7126() {
  dh_initialize_fields('dh_timeseries', 'tstext', 'dh_timeseries');
}

function dh_update_7127() {
  drupal_set_message(t("Updating dH Boreholelog table for integer link to HGU table."));
  db_query("alter table {dh_boreholelog} add column hguid integer ");
} 

function dh_update_7129() {
	$landunit = array('bundle' => 'landunit', 'name' => 'Land Unit', 'description' => 'dH Land Unit');
	dh_base_feature_type_save($landunit);
	drupal_set_message(t("Creating LandUnit Bundle."));
  dh_initialize_fields('landunit');
}

function dh_update_7130() {
  drupal_set_message(t("Updating text processing for proptext"));
  $fields = array();
  $fields[] = array('entity' => 'dh_properties', 'field' => 'proptext');
  foreach ($fields as $thisfield) {
    $entity_type = $thisfield['entity'];
    $field = $thisfield['field'];
    $feature_entity = entity_get_info($entity_type);
    foreach ($feature_entity['bundles'] as $bundle => $binfo) {
      $instance_info = field_info_instance($entity_type, $field, $bundle);
      if ($instance_info) {
		drupal_set_message(t('<pre>'. print_r($instance_info, true) .'</pre>'));
        drupal_set_message(t("Updating widget for $field on $bundle"));
        $instance_info['settings'] = array(
		      'text_processing' => 1,
        );
        // Write the changed definition back.
        field_update_instance($instance_info);
      }
    }
  }  
}  

function dh_update_7131() {
  //add startdate and endate to dh Properties schema
  $tsendtime = array(
    'description' => 'Timestamp for end time value.',
	  'type' => 'int',
	  'not null' => FALSE,
	  'size' => 'big',
  );
  db_add_field( 'dh_timeseries', 'tsendtime', $tsendtime);
}

function dh_update_7133() {
  drupal_set_message(t("Updating text processing for proptext"));
  $fields = array();
  $fields[] = array('entity' => 'dh_properties', 'field' => 'proptext');
  foreach ($fields as $thisfield) {
    $entity_type = $thisfield['entity'];
    $field = $thisfield['field'];
    $feature_entity = entity_get_info($entity_type);
    foreach ($feature_entity['bundles'] as $bundle => $binfo) {
      $instance_info = field_info_instance($entity_type, $field, $bundle);
      if ($instance_info) {
		//drupal_set_message(t('<pre>'. print_r($instance_info, true) .'</pre>'));
        drupal_set_message(t("Updating widget for $field on $bundle"));
        $instance_info['settings'] = array(
		      'text_processing' => 1,
        );
        // Write the changed definition back.
        field_update_instance($instance_info);
      }
    }
  }  
} 

function dh_update_7140() {
  $refdefs = array();
  //  Feature Managing User
  $managed = dh_define_bundles();
  foreach ($managed as $bundle => $binfo) {
    $refdefs[] = array(
      'fieldname' => 'dh_link_feature_mgr_id',
      'src_type' => 'dh_feature',
      'src_bundle' => $bundle,
      'dest_type' => 'user',
      'dest_bundle' => NULL,
      'label' => 'Link from Admin record to Managing User',
      'select_type' => 'entityreference_autocomplete'
    );
  }
  dh_add_references($refdefs, false);
}
 
function dh_update_7141() {
  // remove HGUID field since it is now a direct link
  $fields = array('hguid');
	
  foreach ($fields as $field) {
    drupal_set_message("Removing field '$field'");
	  $numd = 0;
    while (!(field_info_field($field) === NULL)) {
      field_delete_field($field);
      $numd++;
      if ($numd < 10) {
        drupal_set_message("Loop detected - exiting");
        break;
      }
	  }
    drupal_set_message("Deleted $numd fields");
  }
}
 
function dh_update_7142() {
  // rename reserved word status
  db_query("alter table {dh_feature} add column fstatus smallint default 1");
		
}

function dh_update_7143() {
  drupal_set_message(t("Updating text processing for proptext - back to no filter"));
  $fields = array();
  $fields[] = array('entity' => 'dh_properties', 'field' => 'proptext');
  foreach ($fields as $thisfield) {
    $entity_type = $thisfield['entity'];
    $field = $thisfield['field'];
    $feature_entity = entity_get_info($entity_type);
    foreach ($feature_entity['bundles'] as $bundle => $binfo) {
      $instance_info = field_info_instance($entity_type, $field, $bundle);
      if ($instance_info) {
		//drupal_set_message(t('<pre>'. print_r($instance_info, true) .'</pre>'));
        drupal_set_message(t("Updating widget for $field on $bundle"));
        $instance_info['settings'] = array(
		      'text_processing' => 0,
        );
        // Write the changed definition back.
        field_update_instance($instance_info);
      }
    }
  }  
} 

function dh_update_7144() {
  $schema = dh_schema();
  drupal_set_message(t("Adding Bundle table for BoreholeLog"));
	if (!db_table_exists('dh_boreholelog_type')) {
    db_create_table('dh_boreholelog_type', $schema['dh_boreholelog_type']);
  }
	if (!db_field_exists('dh_boreholelog', 'bundle')) {
    db_query("alter table {dh_boreholelog} add column bundle varchar(64) default 'dh_boreholelog'");
  }//db_query("update {dh_boreholelog} set bundle = 'dh_boreholelog' ");
}

function dh_update_7146() {
  drupal_set_message(t("Adding Default Bundle dh_boreholelog"));
  dh_boreholelog_add_bundles();
}
function dh_update_7147() {
	db_query("alter table {dh_timeseries} add column bundle varchar(64) default 'dh_timeseries'");
  db_query("alter table {dh_timeseries} add column timeline smallint default 1");
  db_query("create index dh_ts_tlix on {dh_timeseries} (timeline)");
}

function dh_update_7148() {
  // add these now, then later update the schema
  db_query("alter table {dh_timeseries} alter column bundle set default 'dh_timeseries'");
  db_query("alter table {dh_timeseries} add column entity_type varchar(64) default 'dh_feature'");
  db_query("alter table {dh_properties} add column bundle varchar(64) default 'dh_properties'");
  db_query("alter table {dh_properties} add column entity_type varchar(64) default 'dh_feature'");
}

function dh_update_7150() {
  $schema = dh_schema();
  drupal_set_message(t("Adding Bundle table for Properties"));
	if (!db_table_exists('dh_properties_type')) {
    db_create_table('dh_properties_type', $schema['dh_properties_type']);
  }
	if (!db_field_exists('dh_properties_type', 'bundle')) {
    db_query("alter table {dh_properties} add column bundle varchar(64) default 'dh_properties'");
  }
  dh_properties_add_bundles();
}

function dh_update_7151() {
	if (!db_field_exists('dh_variabledefinition', 'data_entry')) {
    db_query("alter table {dh_variabledefinition} add column data_entry varchar(255) default ''");
  }
}
function dh_update_7154() {
  // next down ID
  $refdefs = array();
  
  $nd_bundles = array('watershed', 'waterbody', 'waterline');
  foreach ($nd_bundles as $bundle) { 
    $refdefs[] = array(
      'fieldname' => 'dh_nextdown_id',
      'src_type' => 'dh_feature',
      'src_bundle' => $bundle,
      'dest_type' => 'dh_feature',
      'dest_bundle' => array('watershed', 'waterbody', 'waterline'),
      'label' => 'Link from one feature to a receiving feature in the flow network',
      'select_type' => 'entityreference_autocomplete'
    );
  }
  dh_add_references($refdefs, true);
}
function dh_update_7155() {
  db_query("alter table {dh_feature} alter column fstatus type varchar(32)");
}

function dh_update_7156() {
  $schema = dh_schema();
	if (!db_field_exists('dh_properties', 'vid')) {
    db_query("alter table {dh_properties} add column vid bigint default 0");
  }
	if (!db_table_exists('dh_properties_revision')) {
    db_create_table('dh_properties_revision', $schema['dh_properties_revision']);
    drupal_set_message(t("Added schema for dh_properties_revision table."));
  }
}

function dh_update_7157() {
	if (!db_field_exists('dh_properties', 'propcode')) {
    db_query("alter table {dh_properties} add column propcode varchar(32) ");
  }
	if (!db_field_exists('dh_properties_revision', 'propcode')) {
    db_query("alter table {dh_properties_revision} add column propcode varchar(32) ");
  }
	if (!db_field_exists('dh_timeseries', 'tscode')) {
    db_query("alter table {dh_timeseries} add column tscode varchar(32) ");
  }
	if (db_table_exists('dh_properties_revision')) {
    db_query("update dh_properties set propname = 'und' where propname is null");
    drupal_set_message(t("Fixed null propname on dh_properties."));
    db_query("insert into dh_properties_revision (pid, varid, propname, propcode, propvalue, startdate, enddate, featureid, entity_type, bundle) select pid, varid, propname, propcode, propvalue, startdate, enddate, featureid, entity_type, bundle from dh_properties where pid not in (select pid from dh_properties_revision)");
    drupal_set_message(t("Added data to dh_properties_revision table."));
    db_query("update dh_properties set vid = foo.vid from ( select max(vid) as vid, pid from dh_properties_revision group by pid ) as foo where dh_properties.pid = foo.pid ");
    drupal_set_message(t("Set dh_properties to point to current revision in dh_properties_revision table."));
  }
   ;
}

function dh_update_7158() {
  db_query("alter table {dh_variabledefinition} alter column varcode type varchar(128)");
}

function dh_update_7159() {
  db_query("alter table {dh_feature} add column uid bigint default 1");
}

function dh_update_7160() {
  db_query("alter table {dh_properties} add column uid bigint default 1");
  db_query("alter table {dh_properties_revision} add column uid bigint default 1");
}

function dh_update_7161() {
  db_query("alter table {dh_timeseries} add column uid bigint default 1");
}

function dh_update_7162() {
  $schema = dh_schema();
  foreach (array('dh_variabledefinition') as $tablename) {
    foreach (array('plugin', 'options') as $colname) {
      if (!db_field_exists($tablename, $colname)) {
        drupal_set_message(t("Adding $colname to $tablename"));
        db_add_field(
          $tablename, 
          $colname, 
          $schema[$tablename]['fields'][$colname]
        );
      }
    }
  }
}

function dh_update_7163() {
  db_query("alter table {dh_properties} add column modified bigint");
  db_query("alter table {dh_properties_revision} add column modified bigint");
}

function dh_update_7164() {
  db_query("alter table {dh_properties} alter column propcode type varchar(64)");
  db_query("alter table {dh_properties_revision} alter column propcode type varchar(64)");
}

function dh_update_7165() {
  db_query("alter table {dh_timeseries} add column modified bigint");
}

function dh_update_7166() {
  db_query("alter table {dh_variabledefinition} add column varabbrev varchar(32)");
}


function dh_update_7167() {
  db_query("alter table {dh_properties} alter column propcode type varchar(255)");
  db_query("alter table {dh_properties_revision} alter column propcode type varchar(255)");
}

function dh_update_7177() {
  db_query("alter table {dh_variabledefinition} add column multiplicity varchar(64)");
}

function dh_update_7178() {
  db_query("drop view if exists view_dh_ows_compliance_due ");
  db_query("drop view if exists view_dh_ows_annual_permit_use");
  db_query("drop view if exists view_dh_ows_monthly_permit_use");
  db_query("drop view if exists view_dh_ows_monthly_group_permit_use");
  db_query("drop view if exists view_dh_ows_wellinfo ");
  db_query("alter table {dh_properties} alter column propname type varchar(255)");
  db_query("alter table {dh_properties_revision} alter column propname type varchar(255)");
}

function dh_update_7179() {
  db_query("create index dh_properties_dh_ps_pnix on {dh_properties} (propname)");
  db_query("create index dh_properties_revision_dh_ps_pnix on {dh_properties_revision} (propname)");
}

function dh_update_7180() {
  // add a timeseries image file at long last 
  if (field_info_instance('dh_timeseries', 'field_image', 'image') === NULL) {
    $info_instance = field_info_instance('dh_properties', 'field_image', 'image');
    $info_instance['entity_type'] = 'dh_timeseries';
    $fa = field_create_instance($instance);
  }
}
?>
